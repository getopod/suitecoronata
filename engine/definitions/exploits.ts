/**
 * Exploit Effect Definitions
 *
 * Exploits are powerful effects that can be game-changing.
 * They often have risk/reward trade-offs or trigger special mechanics.
 */

import { EffectDefinition } from '../patterns/types';
import { isHighestRank, isNextLowerInOrder, isNextHigherInOrder } from '../../utils/rankOrder';
import { Card, Pile, GameState, Rank } from '../../types';

// Helper
const getCardColor = (suit: string) => {
  if (suit === 'hearts' || suit === 'diamonds') return 'red';
  if (suit === 'clubs' || suit === 'spades') return 'black';
  return 'none';
};

export const EXPLOIT_DEFINITIONS: EffectDefinition[] = [
  // ===========================================================================
  // Special Card Exploits
  // ===========================================================================

  {
    id: 'mad_king',
    name: 'Mad King',
    type: 'exploit',
    description: '+4 King of Crowns in deck. Move as Ace, Jack, Queen, or King.',
    custom: {
      onActivate: (state) => {
        const deck = state.piles['deck'];
        const crowns: Card[] = Array.from({ length: 4 }).map((_, i) => ({
          id: `crown-${i}-${Date.now()}`, suit: 'special', rank: 13 as Rank, faceUp: false,
          meta: { crown: true, virtualRanks: [1, 11, 12, 13] as Rank[] }
        }));
        const newDeck = [...deck.cards, ...crowns];
        newDeck.sort(() => Math.random() - 0.5);
        return { piles: { ...state.piles, deck: { ...deck, cards: newDeck } } };
      },
      canMove: (cards, source, target, defaultAllowed) => {
        const c = cards[0];
        if (!c.meta?.crown) return defaultAllowed;
        const top = target.cards[target.cards.length - 1];
        const tryRanks: Rank[] = [1, 11, 12, 13]; // Ace, Jack, Queen, King
        return tryRanks.some(r => {
          const virtual = { ...c, rank: r };
          if (target.type === 'tableau') {
            if (!top) return isHighestRank(virtual.rank);
            return getCardColor(virtual.suit) !== getCardColor(top.suit) &&
                   isNextLowerInOrder(virtual.rank, top.rank);
          }
          if (target.type === 'foundation') {
            if (!top) return virtual.rank === 1;
            return virtual.suit === top.suit && isNextHigherInOrder(virtual.rank, top.rank);
          }
          return false;
        });
      }
    }
  },

  // ===========================================================================
  // Utility Exploits
  // ===========================================================================

  {
    id: 'switcheroo',
    name: 'Switcheroo',
    type: 'exploit',
    description: 'Undo last 3 plays for -20% coins.',
    effectState: { lastSnapshots: [] },
    custom: {
      onActivate: (state) => {
        const cost = Math.floor(state.coins * 0.2);
        if ((state.effectState.lastSnapshots || []).length < 3 || state.coins < cost) return {};
        const snapshot = state.effectState.lastSnapshots[state.effectState.lastSnapshots.length - 3];
        return { ...snapshot, coins: state.coins - cost };
      },
      onMoveComplete: (state) => {
        const snap = { piles: state.piles, score: state.score, coins: state.coins, effectState: state.effectState };
        const prev = [...(state.effectState.lastSnapshots || []), snap].slice(-10);
        return { effectState: { ...state.effectState, lastSnapshots: prev } };
      }
    }
  },

  {
    id: 'trust_fund',
    name: 'Trust Fund',
    type: 'exploit',
    description: 'Convert between points & coins (4:1 or 1:5). Pay 2× score goal to skip encounter (no coin rewards).',
    effectState: {},
    custom: {
      // Conversion handled by UI buttons in App.tsx
      // Skip encounter logic handled in game flow
    }
  },

  // ===========================================================================
  // Coin Exploits
  // ===========================================================================



  // ===========================================================================
  // Minigame Trigger Exploits
  // ===========================================================================

  {
    id: 'one_armed_bandit',
    name: 'One-Armed Bandit',
    type: 'exploit',
    description: 'Have 3 sevens face up in same tableau → Slots minigame.',
    effectState: { slotsTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        const hasCondition = Object.values(state.piles)
          .filter(p => p.type === 'tableau')
          .some(pile => {
            const count = pile.cards.filter(c => c.faceUp && c.rank === 7).length;
            return count >= 3;
          });
        if (hasCondition && !state.effectState.slotsTriggered) {
          return { effectState: { ...state.effectState, slotsTriggered: true }, triggerMinigame: 'slots' };
        }
        return {};
      }
    }
  },

  {
    id: 'fancy_8ball',
    name: 'Fancy 8-ball',
    type: 'exploit',
    description: '4 eights face up in same tableau → Pool minigame.',
    effectState: { poolTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        const hasCondition = Object.values(state.piles)
          .filter(p => p.type === 'tableau')
          .some(pile => {
            const count = pile.cards.filter(c => c.faceUp && c.rank === 8).length;
            return count >= 4;
          });
        if (hasCondition && !state.effectState.poolTriggered) {
          return { effectState: { ...state.effectState, poolTriggered: true }, triggerMinigame: 'pool' };
        }
        return {};
      }
    }
  },

  {
    id: 'ricochet',
    name: 'Ricochet',
    type: 'exploit',
    description: 'Have 4 nines face up in same tableau → Pinball minigame.',
    effectState: { pinballTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        const hasCondition = Object.values(state.piles)
          .filter(p => p.type === 'tableau')
          .some(pile => {
            const count = pile.cards.filter(c => c.faceUp && c.rank === 9).length;
            return count >= 4;
          });
        if (hasCondition && !state.effectState.pinballTriggered) {
          return { effectState: { ...state.effectState, pinballTriggered: true }, triggerMinigame: 'pinball' };
        }
        return {};
      }
    }
  },

  {
    id: 'panopticon_darts',
    name: 'Panopticon',
    type: 'exploit',
    description: 'Have 4 tens face up in same tableau → Darts minigame.',
    effectState: { dartsTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        const hasCondition = Object.values(state.piles)
          .filter(p => p.type === 'tableau')
          .some(pile => {
            const count = pile.cards.filter(c => c.faceUp && c.rank === 10).length;
            return count >= 4;
          });
        if (hasCondition && !state.effectState.dartsTriggered) {
          return { effectState: { ...state.effectState, dartsTriggered: true }, triggerMinigame: 'darts' };
        }
        return {};
      }
    }
  },

  {
    id: 'counting_cards',
    name: 'Counting Cards',
    type: 'exploit',
    description: '4 Jacks face up in same tableau → Blackjack minigame.',
    effectState: { blackjackTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        const hasCondition = Object.values(state.piles)
          .filter(p => p.type === 'tableau')
          .some(pile => {
            const count = pile.cards.filter(c => c.faceUp && c.rank === 11).length;
            return count >= 4;
          });
        if (hasCondition && !state.effectState.blackjackTriggered) {
          return { effectState: { ...state.effectState, blackjackTriggered: true }, triggerMinigame: 'blackjack' };
        }
        return {};
      }
    }
  },

  {
    id: 'russian_roulette',
    name: 'Russian Roulette',
    type: 'exploit',
    description: '4 Kings face up in same tableau → Roulette minigame.',
    effectState: { rouletteTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        const hasCondition = Object.values(state.piles)
          .filter(p => p.type === 'tableau')
          .some(pile => {
            const count = pile.cards.filter(c => c.faceUp && c.rank === 13).length;
            return count >= 4;
          });
        if (hasCondition && !state.effectState.rouletteTriggered) {
          return { effectState: { ...state.effectState, rouletteTriggered: true }, triggerMinigame: 'roulette' };
        }
        return {};
      }
    }
  },

  {
    id: 'rose_glasses',
    name: 'Rose Colored Glasses',
    type: 'exploit',
    description: 'Have 4 of a kind face up in same tableau with 2,3,4,5 → Poker minigame.',
    effectState: { pokerTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        const hasCondition = Object.values(state.piles)
          .filter(p => p.type === 'tableau')
          .some(pile => {
            const counts: Record<number, number> = {};
            pile.cards.forEach(c => { if (c.faceUp) counts[c.rank] = (counts[c.rank] || 0) + 1; });
            return Object.entries(counts).some(([r, cnt]) =>
              [2,3,4,5].includes(Number(r)) && cnt >= 4
            );
          });
        if (hasCondition && !state.effectState.pokerTriggered) {
          return { effectState: { ...state.effectState, pokerTriggered: true }, triggerMinigame: 'poker' };
        }
        return {};
      }
    }
  },

  {
    id: 'weighted_dice',
    name: 'Weighted Dice',
    type: 'exploit',
    description: '3 sixes in foundations but no sevens → Devil\'s Dice.',
    effectState: { devilsDicePlayed: false },
    custom: {
      onMoveComplete: (state) => {
        const fids = Object.keys(state.piles).filter(k => k.startsWith('foundation'));
        let sixes = 0; let sevens = 0;
        fids.forEach(fid => state.piles[fid].cards.forEach(c => {
          if (c.rank === 6) sixes++;
          if (c.rank === 7) sevens++;
        }));
        if (sixes >= 3 && sevens === 0 && !state.effectState.devilsDicePlayed) {
          const d1 = Math.ceil(Math.random() * 6),
                d2 = Math.ceil(Math.random() * 6),
                d3 = Math.ceil(Math.random() * 6);
          const gain = (d1 + d2 + d3) * 100;
          const newPiles = { ...state.piles };
          fids.forEach(fid => {
            newPiles[fid] = { ...newPiles[fid], cards: newPiles[fid].cards.filter(c => c.rank !== 6) };
          });
          return {
            coins: state.coins + gain,
            piles: newPiles,
            effectState: { ...state.effectState, devilsDicePlayed: true }
          };
        }
        return {};
      }
    }
  },

];
