/**
 * Exploit Effect Definitions
 *
 * Exploits are powerful effects that can be game-changing.
 * They often have risk/reward trade-offs or trigger special mechanics.
 */

import { EffectDefinition } from '../patterns/types';
import { isHighestRank, isNextLowerInOrder, isNextHigherInOrder } from '../../utils/rankOrder';
import { Card, Pile, GameState, Rank } from '../../types';

// Helper
const getCardColor = (suit: string) => {
  if (suit === 'hearts' || suit === 'diamonds') return 'red';
  if (suit === 'clubs' || suit === 'spades') return 'black';
  return 'none';
};

export const EXPLOIT_DEFINITIONS: EffectDefinition[] = [
  // ===========================================================================
  // Scoring Exploits
  // ===========================================================================

  {
    id: 'high_society',
    name: 'High Society',
    type: 'exploit',
    description: 'Hand to foundation plays x2 points.',
    scoring: [
      {
        pattern: 'percentage_multiplier',
        trigger: 'source=hand',
        params: { multiplier: 2 }
      }
    ],
    custom: {
      calculateScore: (score, context) =>
        (context.source === 'hand' && context.target.includes('foundation')) ? score * 2 : score
    }
  },

  {
    id: 'compound_interest',
    name: 'Compound Interest',
    type: 'exploit',
    description: 'Each foundation play gives +10% points gained. Each reveal gives +5% current coins.',
    effectState: { compoundPointMult: 1 },
    custom: {
      onEncounterStart: (state) => ({ effectState: { ...state.effectState, compoundPointMult: 1 } }),
      onMoveComplete: (state, context) => {
        const updates: any = {};
        if (context.target.includes('foundation')) {
          updates.effectState = { ...state.effectState,
            compoundPointMult: (state.effectState.compoundPointMult || 1) * 1.1 };
        }
        if (context.reveal) {
          updates.coins = Math.floor(state.coins * 1.05);
        }
        return updates;
      },
      calculateScore: (score, context, state) =>
        Math.floor(score * (state.effectState.compoundPointMult || 1))
    }
  },
  {
    id: 'get_out_of_jail',
    name: 'Get Out of Jail',
    type: 'exploit',
    description: 'Have a royal flush face up in a tableau → Finish encounter immediately.',
    onMoveComplete: (state) => {
      const royalRanks = [10, 11, 12, 13, 1]; // Ten, Jack, Queen, King, Ace
      const suits: Suit[] = ['hearts','diamonds','clubs','spades'];

      const hasRoyalFlush = Object.values(state.piles)
        .filter(p => p.type === 'tableau')
        .some(pile => {
          const faceUps = pile.cards.filter(c => c.faceUp);
          return suits.some(suit => {
            const ranksPresent = faceUps.filter(c => c.suit === suit).map(c => c.rank);
            return royalRanks.every(r => ranksPresent.includes(r));
          });
        });

      if (hasRoyalFlush && !state.effectState.jailTriggered) {
        return { isLevelComplete: true, effectState: { ...state.effectState, jailTriggered: true } };
      }
      return {};
    }
  },
 {
    id: 'loaded_deck',
    name: 'Loaded Deck',
    type: 'exploit',
    description: 'Have 4 Aces face up at once → Add 2 wild Aces to your deck for rest of run.',
    onMoveComplete: (state) => {
      let count = 0;
      Object.values(state.piles).forEach(p =>
        p.cards.forEach(c => { if (c.faceUp && c.rank === 1) count++; })
      );
      if (count >= 4 && !state.effectState.loadedDeckTriggered) {
        const deck = state.piles['deck'];
        const wildAces: Card[] = Array.from({ length: 2 }).map((_, i) => ({
          id: `wild-ace-${i}-${Date.now()}`, suit: 'special', rank: 1, faceUp: false, meta: { isWild: true }
        }));
        return {
          piles: { ...state.piles, deck: { ...deck, cards: [...deck.cards, ...wildAces] } },
          effectState: { ...state.effectState, loadedDeckTriggered: true }
        };
      }
      return {};
    }
  },
  {
    id: 'nepotism',
    name: 'Nepotism',
    type: 'exploit',
    description: 'Have 4 Queens face up at once → 25% discount in next trade.',
    onMoveComplete: (state) => {
      let count = 0;
      Object.values(state.piles).forEach(p =>
        p.cards.forEach(c => { if (c.faceUp && c.rank === 12) count++; })
      );
      if (count >= 4 && !state.effectState.nepotismTriggered) {
        return { effectState: { ...state.effectState, nepotismTriggered: true, tradeDiscount: 0.25 } };
      }
      return {};
    }
  },



  // ===========================================================================
  // Movement Exploits
  // ===========================================================================

  {
    id: 'anarchists_cookbook',
    name: "Anarchist's Cookbook",
    type: 'exploit',
    description: 'Build foundations in any order once aces are placed.',
    custom: {
      canMove: (cards, source, target, defaultAllowed) => {
        if (target.type === 'foundation') {
          const moving = cards[0]; const top = target.cards[target.cards.length - 1];
          if (!top) return moving.rank === 1;
          return moving.suit === top.suit && (isNextHigherInOrder(moving.rank, top.rank) ||
                 isNextLowerInOrder(moving.rank, top.rank));
        }
        return defaultAllowed;
      }
    }
  },

  // ===========================================================================
  // Special Card Exploits
  // ===========================================================================

  {
    id: 'mad_king',
    name: 'Mad King',
    type: 'exploit',
    description: '+4 King of Crowns in deck. Move as Ace, Jack, Queen, or King.',
    custom: {
      onActivate: (state) => {
        const deck = state.piles['deck'];
        const crowns: Card[] = Array.from({ length: 4 }).map((_, i) => ({
          id: `crown-${i}-${Date.now()}`, suit: 'special', rank: 13 as Rank, faceUp: false,
          meta: { crown: true, virtualRanks: [1, 11, 12, 13] as Rank[] }
        }));
        const newDeck = [...deck.cards, ...crowns];
        newDeck.sort(() => Math.random() - 0.5);
        return { piles: { ...state.piles, deck: { ...deck, cards: newDeck } } };
      },
      canMove: (cards, source, target, defaultAllowed) => {
        const c = cards[0];
        if (!c.meta?.crown) return defaultAllowed;
        const top = target.cards[target.cards.length - 1];
        const tryRanks: Rank[] = [1, 11, 12, 13]; // Ace, Jack, Queen, King
        return tryRanks.some(r => {
          const virtual = { ...c, rank: r };
          if (target.type === 'tableau') {
            if (!top) return isHighestRank(virtual.rank);
            return getCardColor(virtual.suit) !== getCardColor(top.suit) &&
                   isNextLowerInOrder(virtual.rank, top.rank);
          }
          if (target.type === 'foundation') {
            if (!top) return virtual.rank === 1;
            return virtual.suit === top.suit && isNextHigherInOrder(virtual.rank, top.rank);
          }
          return false;
        });
      }
    }
  },

  // ===========================================================================
  // Utility Exploits
  // ===========================================================================

  {
    id: 'switcheroo',
    name: 'Switcheroo',
    type: 'exploit',
    description: 'Undo last 3 plays for -20% coins.',
    effectState: { lastSnapshots: [] },
    custom: {
      onActivate: (state) => {
        const cost = Math.floor(state.coins * 0.2);
        if ((state.effectState.lastSnapshots || []).length < 3 || state.coins < cost) return {};
        const snapshot = state.effectState.lastSnapshots[state.effectState.lastSnapshots.length - 3];
        return { ...snapshot, coins: state.coins - cost };
      },
      onMoveComplete: (state) => {
        const snap = { piles: state.piles, score: state.score, coins: state.coins, effectState: state.effectState };
        const prev = [...(state.effectState.lastSnapshots || []), snap].slice(-10);
        return { effectState: { ...state.effectState, lastSnapshots: prev } };
      }
    }
  },

  {
    id: 'insider_trading',
    name: 'Insider Trading',
    type: 'exploit',
    description: 'All face cards visible → x3 encounter reward.',
    visuals: [
      { pattern: 'face_cards_visible' }
    ]
  },

  {
    id: 'trust_fund',
    name: 'Trust Fund',
    type: 'exploit',
    description: 'Convert between points & coins (4:1 or 1:5). Pay 2× score goal to skip encounter (no coin rewards).',
    effectState: {},
    custom: {
      // Conversion handled by UI buttons in App.tsx
      // Skip encounter logic handled in game flow
    }
  },

  {
    id: 'keen_instincts',
    name: 'Keen Instincts',
    type: 'exploit',
    description: 'Revealed cards ignore rank & give +10 coin if played immediately.',
    custom: {
      canMove: (cards, source, target, defaultAllowed, state) => {
        const c = cards[0];
        if (c.id === state.effectState.justRevealedCardId && target.type === 'tableau') return true;
        return defaultAllowed;
      },
      onMoveComplete: (state, context) => {
        if (context.cards[0]?.id === state.effectState.justRevealedCardId) {
          return { coins: state.coins + 10, effectState: { ...state.effectState, justRevealedCardId: null } };
        }
        return {};
      }
    }
  },

  // ===========================================================================
  // Coin Exploits
  // ===========================================================================

  {
    id: 'venture_capitol',
    name: 'Venture Capitol',
    type: 'exploit',
    description: 'Foundation plays +20 coin. Completions +100 coin.',
    custom: {
      calculateCoinTransaction: (delta, context, state) => {
        if (context.target.includes('foundation')) {
          const pile = state.piles[context.target];
          const willBe = pile.cards.length + context.cards.length;
          return delta + 20 + (willBe === 13 ? 100 : 0);
        }
        return delta;
      }
    }
  },

  {
    id: 'tax_loophole',
    name: 'Tax Loophole',
    type: 'exploit',
    description: 'Buy a key for 25% of your coin. It works anywhere.',
    custom: {
      onActivate: (state) => {
        if (state.coins <= 0) return {};
        const cost = Math.floor(state.coins * 0.25);
        const hand = state.piles['hand'];
        const key: Card = { id: `key-${Date.now()}`, suit: 'special', rank: 0 as Rank, faceUp: true,
                            meta: { isKey: true, universal: true } };
        return {
          coins: state.coins - cost,
          piles: { ...state.piles, hand: { ...hand, cards: [...hand.cards, key] } }
        };
      }
    }
  },
   { id: 'breaking_entering',
    name: 'Breaking & Entering',
    type: 'exploit',
    description: 'Have a Full House face up in a tableau → Unlock all tableau.',
    onMoveComplete: (state) => {
      const tableauCards = Object.values(state.piles)
        .filter(p => p.type === 'tableau')
        .flatMap(p => p.cards.filter(c => c.faceUp));
      const rankCounts: Record<number, number> = {};
      tableauCards.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1; });
      const hasThree = Object.values(rankCounts).some(cnt => cnt >= 3);
      const hasTwo = Object.values(rankCounts).some(cnt => cnt >= 2);
      if (hasThree && hasTwo && !state.effectState.breakingTriggered) {
        const newPiles = { ...state.piles };
        Object.keys(newPiles).filter(k => k.startsWith('tableau')).forEach(id => {
          newPiles[id] = { ...newPiles[id], locked: false };
        });
        return { piles: newPiles, effectState: { ...state.effectState, breakingTriggered: true } };
      }
      return {};
    }
  },

  // ===========================================================================
  // Minigame Trigger Exploits
  // ===========================================================================

  {
    id: 'one_armed_bandit',
    name: 'One-Armed Bandit',
    type: 'exploit',
    description: 'Have 3 sevens face up at once → Slots minigame.',
    effectState: { slotsTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        let count = 0;
        Object.values(state.piles).forEach(p =>
          p.cards.forEach(c => { if (c.faceUp && c.rank === 7) count++; })
        );
        if (count >= 3 && !state.effectState.slotsTriggered) {
          return { effectState: { ...state.effectState, slotsTriggered: true }, triggerMinigame: 'slots' };
        }
        return {};
      }
    }
  },

  {
    id: 'fancy_8ball',
    name: 'Fancy 8-ball',
    type: 'exploit',
    description: '4 eights face up at once → Pool minigame.',
    effectState: { poolTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        let count = 0;
        Object.values(state.piles).forEach(p =>
          p.cards.forEach(c => { if (c.faceUp && c.rank === 8) count++; })
        );
        if (count >= 4 && !state.effectState.poolTriggered) {
          return { effectState: { ...state.effectState, poolTriggered: true }, triggerMinigame: 'pool' };
        }
        return {};
      }
    }
  },

  {
    id: 'ricochet',
    name: 'Ricochet',
    type: 'exploit',
    description: 'Have 4 nines face up at once → Pinball minigame.',
    effectState: { pinballTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        let count = 0;
        Object.values(state.piles).forEach(p =>
          p.cards.forEach(c => { if (c.faceUp && c.rank === 9) count++; })
        );
        if (count >= 4 && !state.effectState.pinballTriggered) {
          return { effectState: { ...state.effectState, pinballTriggered: true }, triggerMinigame: 'pinball' };
        }
        return {};
      }
    }
  },

  {
    id: 'panopticon_darts',
    name: 'Panopticon',
    type: 'exploit',
    description: 'Have 4 tens face up at once → Darts minigame.',
    effectState: { dartsTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        let count = 0;
        Object.values(state.piles).forEach(p =>
          p.cards.forEach(c => { if (c.faceUp && c.rank === 10) count++; })
        );
        if (count >= 4 && !state.effectState.dartsTriggered) {
          return { effectState: { ...state.effectState, dartsTriggered: true }, triggerMinigame: 'darts' };
        }
        return {};
      }
    }
  },

  {
    id: 'counting_cards',
    name: 'Counting Cards',
    type: 'exploit',
    description: '4 Jacks face up at once → Blackjack minigame.',
    effectState: { blackjackTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        let count = 0;
        Object.values(state.piles).forEach(p =>
          p.cards.forEach(c => { if (c.faceUp && c.rank === 11) count++; })
        );
        if (count >= 4 && !state.effectState.blackjackTriggered) {
          return { effectState: { ...state.effectState, blackjackTriggered: true }, triggerMinigame: 'blackjack' };
        }
        return {};
      }
    }
  },

  {
    id: 'russian_roulette',
    name: 'Russian Roulette',
    type: 'exploit',
    description: '4 Kings face up at once → Roulette minigame.',
    effectState: { rouletteTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        let count = 0;
        Object.values(state.piles).forEach(p =>
          p.cards.forEach(c => { if (c.faceUp && c.rank === 13) count++; })
        );
        if (count >= 4 && !state.effectState.rouletteTriggered) {
          return { effectState: { ...state.effectState, rouletteTriggered: true }, triggerMinigame: 'roulette' };
        }
        return {};
      }
    }
  },

  {
    id: 'rose_glasses',
    name: 'Rose Colored Glasses',
    type: 'exploit',
    description: 'Have 4 of a kind face up with 2,3,4,5 → Poker minigame.',
    effectState: { pokerTriggered: false },
    custom: {
      onMoveComplete: (state) => {
        const counts: Record<number, number> = {};
        Object.values(state.piles).forEach(p =>
          p.cards.forEach(c => { if (c.faceUp) counts[c.rank] = (counts[c.rank] || 0) + 1; })
        );
        const has4Kind = Object.entries(counts).some(([r, cnt]) =>
          [2,3,4,5].includes(Number(r)) && cnt >= 4
        );
        if (has4Kind && !state.effectState.pokerTriggered) {
          return { effectState: { ...state.effectState, pokerTriggered: true }, triggerMinigame: 'poker' };
        }
        return {};
      }
    }
  },

  {
    id: 'weighted_dice',
    name: 'Weighted Dice',
    type: 'exploit',
    description: '3 sixes in foundations but no sevens → Devil\'s Dice.',
    effectState: { devilsDicePlayed: false },
    custom: {
      onMoveComplete: (state) => {
        const fids = Object.keys(state.piles).filter(k => k.startsWith('foundation'));
        let sixes = 0; let sevens = 0;
        fids.forEach(fid => state.piles[fid].cards.forEach(c => {
          if (c.rank === 6) sixes++;
          if (c.rank === 7) sevens++;
        }));
        if (sixes >= 3 && sevens === 0 && !state.effectState.devilsDicePlayed) {
          const d1 = Math.ceil(Math.random() * 6),
                d2 = Math.ceil(Math.random() * 6),
                d3 = Math.ceil(Math.random() * 6);
          const gain = (d1 + d2 + d3) * 100;
          const newPiles = { ...state.piles };
          fids.forEach(fid => {
            newPiles[fid] = { ...newPiles[fid], cards: newPiles[fid].cards.filter(c => c.rank !== 6) };
          });
          return {
            coins: state.coins + gain,
            piles: newPiles,
            effectState: { ...state.effectState, devilsDicePlayed: true }
          };
        }
        return {};
      }
    }
  },

];
